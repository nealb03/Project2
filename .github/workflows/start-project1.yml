name: START - Project1 Backend (EC2 + SSM)

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.PROJECT1_EC2_INSTANCE_ID }}

  API_DIR: 'C:\Backend01\MyWebApi'
  DLL_NAME: 'MyWebApi.dll'
  PORT: "5001"

  LOG_DIR: 'C:\Apps\logs'
  OUT_LOG: 'C:\Apps\logs\api-out.txt'
  ERR_LOG: 'C:\Apps\logs\api-err.txt'
  PID_FILE: 'C:\Apps\logs\api.pid'

  HEALTH_URL: 'http://127.0.0.1:5001/api/health'

jobs:
  start:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure EC2 is running
        shell: bash
        run: |
          set -euo pipefail
          state=$(aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" --query "Reservations[0].Instances[0].State.Name" --output text)
          echo "Instance state: $state"
          if [ "$state" != "running" ]; then
            aws ec2 start-instances --instance-ids "${INSTANCE_ID}" >/dev/null
            aws ec2 wait instance-running --instance-ids "${INSTANCE_ID}"
          fi

      - name: Wait for SSM Online
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..60}; do
            ping=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="${INSTANCE_ID}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || true)

            if [ "$ping" = "Online" ]; then
              echo "SSM is Online"
              exit 0
            fi

            echo "SSM not Online yet (got: $ping). Sleeping 10s..."
            sleep 10
          done

          echo "SSM did not become Online. Ensure SSM Agent is installed/running and instance role has AmazonSSMManagedInstanceCore."
          exit 1

      - name: Start backend via SSM
        id: ssm_start
        shell: bash
        run: |
          set -euo pipefail

          # PowerShell script (do NOT use heredoc-within-aws-cli; we'll base64 encode)
          PS_SCRIPT=$(cat <<'EOF'
          $ErrorActionPreference = "Stop"

          $apiDir  = "${env:API_DIR}"
          $dllName = "${env:DLL_NAME}"
          $outLog  = "${env:OUT_LOG}"
          $errLog  = "${env:ERR_LOG}"
          $pidFile = "${env:PID_FILE}"
          $health  = "${env:HEALTH_URL}"

          New-Item -ItemType Directory -Force -Path (Split-Path $outLog) | Out-Null

          "----- START $(Get-Date -Format o) -----" | Out-File -FilePath $outLog -Append
          "apiDir=$apiDir dll=$dllName" | Out-File -FilePath $outLog -Append

          # If already running, exit cleanly
          if (Test-Path $pidFile) {
            try {
              $pid = Get-Content $pidFile -ErrorAction Stop
              if ($pid -and (Get-Process -Id $pid -ErrorAction SilentlyContinue)) {
                "Already running pid=$pid" | Out-File -FilePath $outLog -Append
                exit 0
              }
            } catch {}
          }

          # Start dotnet process
          $dllPath = Join-Path $apiDir $dllName
          if (!(Test-Path $dllPath)) {
            throw "DLL not found: $dllPath"
          }

          $p = Start-Process -FilePath "dotnet" -ArgumentList "`"$dllPath`"" -WorkingDirectory $apiDir -PassThru -WindowStyle Hidden
          $p.Id | Out-File -FilePath $pidFile -Force

          "Started pid=$($p.Id)" | Out-File -FilePath $outLog -Append

          # Optional health check (local on instance)
          if ($health -and $health.Trim().Length -gt 0) {
            for ($i=0; $i -lt 60; $i++) {
              try {
                $r = Invoke-WebRequest -UseBasicParsing -Uri $health -TimeoutSec 3
                if ($r.StatusCode -ge 200 -and $r.StatusCode -lt 500) {
                  "Health OK: $($r.StatusCode)" | Out-File -FilePath $outLog -Append
                  exit 0
                }
              } catch {
                "Health not ready yet: $($_.Exception.Message)" | Out-File -FilePath $errLog -Append
              }
              Start-Sleep -Seconds 5
            }
            throw "Health check never became ready: $health"
          }

          "START OK (no health check configured)" | Out-File -FilePath $outLog -Append
          EOF
          )

          # Base64 encode the script for safe transport
          PS_B64=$(printf "%s" "$PS_SCRIPT" | base64 -w0)

          # Build ONE PowerShell command that decodes + runs the script
          # Note: AWS-RunPowerShellScript takes an array of commands; we pass a single command line.
          RUN="powershell -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command \"\$b64='$PS_B64'; \$s=[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(\$b64)); iex \$s\""

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunPowerShellScript" \
            --comment "Start Project1 backend" \
            --parameters "commands=$RUN" \
            --query "Command.CommandId" --output text)

          echo "command_id=$CMD_ID" >> "$GITHUB_OUTPUT"
          echo "SSM CommandId: $CMD_ID"

          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "${INSTANCE_ID}"

      - name: Show SSM result + fail if not Success
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.ssm_start.outputs.command_id }}"

          status=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" --output text)

          echo "SSM status: $status"

          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "${INSTANCE_ID}" \
            --query "{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}" \
            --output json

          test "$status" = "Success"