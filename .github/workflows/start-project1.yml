name: START - Project1 Backend (NO SSM)

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.PROJECT1_EC2_INSTANCE_ID }}

  # Backend port (used for health check and URL output)
  PORT: "5001"

  # Public health endpoint (from the runner). Change if needed.
  # If you don't have a public health endpoint, set to empty to skip.
  HEALTH_PATH: "/api/health"

jobs:
  start:
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure EC2 is running (start if needed)
        shell: bash
        run: |
          set -euo pipefail
          IID="${INSTANCE_ID}"

          state=$(aws ec2 describe-instances \
            --instance-ids "$IID" \
            --query "Reservations[0].Instances[0].State.Name" \
            --output text)

          echo "Instance state: $state"

          if [ "$state" != "running" ]; then
            echo "Starting instance..."
            aws ec2 start-instances --instance-ids "$IID" >/dev/null
          fi

          echo "Waiting for instance-running..."
          aws ec2 wait instance-running --instance-ids "$IID"
          echo "Instance is running."

      - name: Get Public IP (or Public DNS)
        id: ip
        shell: bash
        run: |
          set -euo pipefail
          IID="${INSTANCE_ID}"

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids "$IID" \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)

          PUBLIC_DNS=$(aws ec2 describe-instances \
            --instance-ids "$IID" \
            --query "Reservations[0].Instances[0].PublicDnsName" \
            --output text)

          echo "Public IP:  $PUBLIC_IP"
          echo "Public DNS: $PUBLIC_DNS"

          echo "public_ip=$PUBLIC_IP" >> "$GITHUB_OUTPUT"
          echo "public_dns=$PUBLIC_DNS" >> "$GITHUB_OUTPUT"

      - name: Wait for OS/services to settle (boot delay)
        shell: bash
        run: |
          echo "Sleeping 90 seconds for boot..."
          sleep 90

      - name: Optional - Trigger backend start via HTTP (NO SSM)
        shell: bash
        env:
          START_URL: ${{ secrets.PROJECT1_BACKEND_START_URL }}
        run: |
          set -euo pipefail
          if [ -z "${START_URL:-}" ]; then
            echo "No PROJECT1_BACKEND_START_URL configured; skipping HTTP start trigger."
            echo "Assuming backend auto-starts (service/task/IIS/NSSM)."
            exit 0
          fi
          echo "Calling backend start trigger: $START_URL"
          curl -fsS -X POST "$START_URL"

      - name: Health check (public)
        shell: bash
        run: |
          set -euo pipefail

          IP="${{ steps.ip.outputs.public_ip }}"
          if [ -z "${IP:-}" ] || [ "$IP" = "None" ]; then
            echo "No public IP found. Cannot run public health check."
            exit 1
          fi

          if [ -z "${{ env.HEALTH_PATH }}" ]; then
            echo "HEALTH_PATH empty; skipping."
            exit 0
          fi

          URL="http://${IP}:${{ env.PORT }}${{ env.HEALTH_PATH }}"
          echo "Checking: $URL"

          # Retry because backend may still be coming up
          for i in {1..20}; do
            if curl -fsS "$URL" >/dev/null; then
              echo "Health check OK."
              exit 0
            fi
            echo "Not ready yet. Attempt $i/20. Sleeping 6s..."
            sleep 6
          done

          echo "Health check failed after retries."
          exit 1

      - name: Summary
        shell: bash
        run: |
          echo "Project1 start workflow complete (NO SSM)."
          echo "Backend URL: http://${{ steps.ip.outputs.public_ip }}:${{ env.PORT }}"