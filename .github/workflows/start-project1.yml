name: Start Project1 (EC2 + Backend)

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS Region"
        required: true
        default: "us-east-1"
      instance_id:
        description: "EC2 instance id"
        required: true
        default: "i-0aa128f11e1299832"
      port:
        description: "Backend port"
        required: true
        default: "5001"

permissions:
  id-token: write
  contents: read

jobs:
  start:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC (PROD)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::288761763536:role/GithubActionsRole
          aws-region: ${{ inputs.aws_region }}

      - name: Start EC2 and wait until running
        shell: bash
        run: |
          set -euo pipefail
          aws ec2 start-instances --instance-ids "${{ inputs.instance_id }}" --output table
          aws ec2 wait instance-running --instance-ids "${{ inputs.instance_id }}"

      - name: Wait for SSM agent Online (best effort; do not fail job)
        shell: bash
        run: |
          set -euo pipefail
          INSTANCE_ID="${{ inputs.instance_id }}"

          echo "Waiting for SSM Online for $INSTANCE_ID (best effort)..."
          for i in $(seq 1 60); do
            STATUS="$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || true)"
            echo "SSM PingStatus: ${STATUS:-<none>}"
            if [ "$STATUS" = "Online" ]; then
              echo "SSM is Online."
              exit 0
            fi
            sleep 10
          done

          echo "SSM did not become Online in time. Continuing anyway (will try send-command)."
          exit 0

      - name: Start Backend via SSM (fire-and-forget; ignore errors)
        shell: bash
        run: |
          set -euo pipefail
          INSTANCE_ID="${{ inputs.instance_id }}"
          PORT="${{ inputs.port }}"

          cat > start-backend.ps1 <<'PS1'
          $ErrorActionPreference = "Stop"
          $port = "__PORT__"

          # From your manual run / screenshot:
          $apiDir = "C:\Backend01\MyWebApi"
          if (!(Test-Path $apiDir)) { throw "API_DIR not found: $apiDir" }

          # If your csproj name differs, change it here:
          $csproj = Join-Path $apiDir "MyWebApi.csproj"
          if (!(Test-Path $csproj)) { throw "CSPROJ not found: $csproj" }

          $logDir = "C:\Apps\logs"
          New-Item -ItemType Directory -Force -Path $logDir | Out-Null

          # Stop old PID if it exists
          $pidFile = Join-Path $logDir "api.pid"
          if (Test-Path $pidFile) {
            try {
              $oldPid = (Get-Content $pidFile -ErrorAction SilentlyContinue)
              if ($oldPid) { Stop-Process -Id $oldPid -Force -ErrorAction SilentlyContinue }
              Remove-Item $pidFile -Force -ErrorAction SilentlyContinue
            } catch {}
          }

          $ts = Get-Date -Format "yyyyMMdd-HHmmss"
          $outLog = Join-Path $logDir ("api-out-" + $ts + ".txt")
          $errLog = Join-Path $logDir ("api-err-" + $ts + ".txt")

          # Find dotnet reliably (SSM runs as SYSTEM)
          $dotnet = (Get-Command dotnet -ErrorAction SilentlyContinue).Source
          if (!$dotnet) {
            $fallback = "C:\Program Files\dotnet\dotnet.exe"
            if (Test-Path $fallback) { $dotnet = $fallback } else { throw "dotnet not found (PATH and $fallback missing)" }
          }

          $argList = @(
            "run",
            "--project", "`"$csproj`"",
            "--urls", "http://0.0.0.0:$port"
          ) -join " "

          # Start detached and log stdout/stderr to files
          $p = Start-Process -FilePath $dotnet `
            -ArgumentList $argList `
            -WorkingDirectory $apiDir `
            -WindowStyle Hidden `
            -RedirectStandardOutput $outLog `
            -RedirectStandardError $errLog `
            -PassThru

          $p.Id | Out-File -FilePath $pidFile -Force
          "Started PID=$($p.Id) on port $port. Out=$outLog Err=$errLog" | Out-File -FilePath $outLog -Append
          PS1

          sed -i "s/__PORT__/${PORT}/g" start-backend.ps1
          B64="$(base64 -w 0 start-backend.ps1)"

          # Fire-and-forget: send the SSM command, do not wait/poll, and never fail the workflow.
          COMMAND_ID="$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunPowerShellScript" \
            --comment "Start backend detached (fire-and-forget)" \
            --parameters "{\"commands\":[\"[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('$B64')) | Set-Content -Path C:\\\\Windows\\\\Temp\\\\start-backend.ps1 -Encoding UTF8\",\"powershell.exe -NoProfile -ExecutionPolicy Bypass -File C:\\\\Windows\\\\Temp\\\\start-backend.ps1\"]}" \
            --query "Command.CommandId" \
            --output text 2>/dev/null || true)"

          if [ -n "${COMMAND_ID:-}" ] && [ "${COMMAND_ID:-None}" != "None" ]; then
            echo "SSM CommandId: $COMMAND_ID"
          else
            echo "SSM send-command did not return a CommandId (ignored)."
          fi

          # Optional: one best-effort status fetch (no waiting)
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "{Status:Status,ResponseCode:ResponseCode}" \
            --output table 2>/dev/null || true

          # Always succeed this step
          exit 0