name: START - Project1 Backend (EC2 + SSM, starts BE)

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  INSTANCE_ID: ${{ secrets.PROJECT1_EC2_INSTANCE_ID }}

  API_DIR: 'C:\Backend01\MyWebApi'
  PORT: "5001"
  OUT_LOG: 'C:\Apps\logs\api-out.txt'
  ERR_LOG: 'C:\Apps\logs\api-err.txt'
  PID_FILE: 'C:\Apps\logs\api.pid'

jobs:
  start:
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure EC2 is running
        shell: bash
        run: |
          set -euo pipefail
          state=$(aws ec2 describe-instances --instance-ids "${INSTANCE_ID}" --query "Reservations[0].Instances[0].State.Name" --output text)
          echo "Instance state: $state"
          if [ "$state" != "running" ]; then
            aws ec2 start-instances --instance-ids "${INSTANCE_ID}" >/dev/null
            aws ec2 wait instance-running --instance-ids "${INSTANCE_ID}"
          fi

      - name: Wait for SSM Online (max ~60s)
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..12}; do
            ping=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="${INSTANCE_ID}" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text 2>/dev/null || true)
            echo "SSM PingStatus: ${ping:-<empty>}"
            if [ "$ping" = "Online" ]; then
              exit 0
            fi
            sleep 5
          done
          echo "SSM did not become Online within the timeout."
          exit 1

      - name: Start backend via SSM (dotnet run)
        id: ssm_start
        shell: bash
        run: |
          set -euo pipefail

          # Escape backslashes for JSON (C:\Path -> C:\\Path)
          API_DIR_ESC=${API_DIR//\\/\\\\}
          OUT_LOG_ESC=${OUT_LOG//\\/\\\\}
          ERR_LOG_ESC=${ERR_LOG//\\/\\\\}
          PID_FILE_ESC=${PID_FILE//\\/\\\\}

          # Build JSON parameters safely using a heredoc
          PARAMS=$(cat <<EOF
          {
            "commands": [
              "\$ErrorActionPreference = \\"Stop\\"",
              "\$apiDir  = \\"$API_DIR_ESC\\"",
              "\$port    = \\"$PORT\\"",
              "\$outLog  = \\"$OUT_LOG_ESC\\"",
              "\$errLog  = \\"$ERR_LOG_ESC\\"",
              "\$pidFile = \\"$PID_FILE_ESC\\"",

              "New-Item -ItemType Directory -Force -Path (Split-Path \$outLog) | Out-Null",
              "\\"----- START \$(Get-Date -Format o) -----\\" | Out-File -FilePath \$outLog -Append",
              "\\"API_DIR=\$apiDir PORT=\$port\\" | Out-File -FilePath \$outLog -Append",

              "if (!(Test-Path \$apiDir)) { throw \\"API_DIR not found: \$apiDir\\" }",

              "if (Test-Path \$pidFile) {",
              "  try {",
              "    \$pid = (Get-Content \$pidFile -ErrorAction Stop)",
              "    if (\$pid -and (Get-Process -Id \$pid -ErrorAction SilentlyContinue)) {",
              "      \\"Already running pid=\$pid\\" | Out-File -FilePath \$outLog -Append",
              "      exit 0",
              "    }",
              "  } catch {}",
              "}",

              "\$cmd = \\"cd /d `\\"\\$apiDir`\\" && dotnet run --urls http://0.0.0.0:\\$port 1>> `\\"\\$outLog`\\" 2>> `\\"\\$errLog`\\"\\"",
              "\\"CMD: \$cmd\\" | Out-File -FilePath \$outLog -Append",

              "\$p = Start-Process -FilePath \\"cmd.exe\\" -ArgumentList \\"/c\\", \$cmd -WindowStyle Hidden -PassThru",
              "\$p.Id | Out-File -FilePath \$pidFile -Force",
              "\\"Started pid=\$((\$p).Id)\\" | Out-File -FilePath \$outLog -Append"
            ]
          }
          EOF
          )

          echo "SSM parameters JSON (sanitized):"
          echo "$PARAMS" | sed 's/[A-Za-z]:\\\\[^"]*/<WIN_PATH>/g' || true

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunPowerShellScript" \
            --comment "Start Project1 backend via dotnet run (SSM)" \
            --parameters "$PARAMS" \
            --query "Command.CommandId" --output text)

          echo "command_id=$CMD_ID" >> "$GITHUB_OUTPUT"
          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "${INSTANCE_ID}"

      - name: Show SSM invocation result
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.ssm_start.outputs.command_id }}"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "${INSTANCE_ID}" \
            --query "{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}" \
            --output json