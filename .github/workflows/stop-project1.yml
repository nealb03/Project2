name: Stop Project1 Backend

on:
  workflow_dispatch:

jobs:
  stop:
    runs-on: ubuntu-latest

    steps:
      - name: Build valid JSON parameters (escape-safe)
        id: build
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # This is the command we want the remote side to run.
          # Keep it SIMPLE here; do not try to hand-craft JSON with C:\ paths.
          $remoteCommands = @(
            '$ErrorActionPreference = "SilentlyContinue"'
            '$pidFile = "C:\Apps\logs\api.pid"'
            'if (Test-Path $pidFile) {'
            '  $pid = Get-Content $pidFile'
            '  if ($pid) { Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue }'
            '  Remove-Item $pidFile -Force -ErrorAction SilentlyContinue'
            '}'
          )

          # Build the exact JSON your CLI expects: { "commands": [ ... ] }
          $payload = @{ commands = $remoteCommands } | ConvertTo-Json -Compress

          # Expose as an output for later steps
          "json=$payload" >> $env:GITHUB_OUTPUT

      - name: Stop backend using CLI (passes valid JSON)
        shell: bash
        env:
          RUN_JSON: ${{ steps.build.outputs.json }}
        run: |
          set -euo pipefail

          # Example placeholder: replace this with your real CLI invocation.
          # IMPORTANT: we pass the JSON as a single argument, already correctly escaped.
          #
          # If your CLI is AWS SSM, it typically looks like:
          # aws ssm send-command --document-name "AWS-RunPowerShellScript" --parameters "$RUN_JSON" ...
          #
          # Keep the quoting EXACTLY like this.
          your-cli-command-here \
            --parameters "$RUN_JSON"